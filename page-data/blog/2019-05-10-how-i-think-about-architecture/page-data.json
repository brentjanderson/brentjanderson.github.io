{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/2019-05-10-how-i-think-about-architecture/","result":{"data":{"markdownRemark":{"html":"<p>Software engineers sometimes talk about architecture. I can't say this word by\nitself ever came up in college, and it's application has always felt nebulous.\nConcretely:</p>\n<ul>\n<li>What do we mean by \"Software Architecture\"?</li>\n<li>What makes for good software architecture?</li>\n<li>How can we improve existing architectures?</li>\n</ul>\n<h2>What is software architecture</h2>\n<p>Wikipedia gives us <a href=\"https://en.wikipedia.org/wiki/Architecture#Definitions_and_etymology\">as sound a definition</a> as any:</p>\n<blockquote>\n<p>Architecture is both the process and the product of planning, designing, and\nconstructing buildings and other physical structures.</p>\n</blockquote>\n<p>The roots of the word architecture are, unsurprisingly, from two Greek words\nmeaning \"chief creator\". Architecture also carries some implied meanings:</p>\n<ul>\n<li>It serves a complex set of needs and purposes from different stakeholders</li>\n<li>Unifying patterns that apply progressively from macro- to micro-levels</li>\n<li>It applies to systems composed of physical and logical elements</li>\n<li>It's a form of art, and describes various styles over time</li>\n</ul>\n<p>Thus:</p>\n<blockquote>\n<p>Architecture is the practice of designing unified patterns that, when applied,\nproduce physical and logical elements that serve a complex set of\nheterogenous needs from various stakeholders over time.</p>\n</blockquote>\n<h2>Good software architecture</h2>\n<p>\"Good\" architecture is therefore couched within the definition of an instance of\narchitecture. What makes one architecture \"good\" is poor in another context. One\nuniversal measure of good architecture is whether it stands the test of time.\nAncient buildings are revered and studied because they have consistently met\nstakeholder needs over an extended period of time. Likewise, concepts in\nsoftware engineering that continually meet user needs become elements of\ngood architecture over time. The standard libaries of most langauges,\npatterns regarding state management, and foundational protocols are\nall elements that combine to create good software architecture.</p>\n<p>Thus, what makes for good software architecture is a combination of time-tested\nsoftware elements and components layered with strategies for ensuring that the\nsoftware can continually serve the domain in which it operates for the horizon\nof the system's usefulness. Building a system that we intend to last for\nmillenia is a much harder proposition than one that we intend to last\nfor a decade, much less a week. Even so, the difference betweeen one\nmillenium and a decade is not that much given that we can hardly\npredict the future beyond a few months with sure certainty.</p>\n<p>Therefore, when a system has an unknown shelf life that is likely to span many\nyears, we need strategies to support the continuous evolution of the system.</p>\n<h2>Improving existing architecture</h2>\n<p>I think the first step with improving (or establishing) architecture is to\n<a href=\"https://en.wikipedia.org/wiki/List_of_system_quality_attributes\">define the qualities the system should conform to</a>, and for the\nsystem to enforce those qualities as part of quality verification. In\npractice, this means to include architecture qualities as part of\nautomated tests.</p>\n<p>TODO: Finish thoughts here</p>","frontmatter":{"date":"May 10, 2019","title":"How I Think About Architecture"},"fields":{"slug":"/blog/2019-05-10-how-i-think-about-architecture/"}}},"pageContext":{}}}