{"data":{"markdownRemark":{"html":"<p>\n  <figure class=\"gatsby-resp-image-figure\" style=\"\">\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 1100px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAQFAgP/xAAWAQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAZ7MnY0cCb//xAAaEAEAAgMBAAAAAAAAAAAAAAABAAIDERMi/9oACAEBAAEFAjIQ9CaZW9qzqs//xAAYEQACAwAAAAAAAAAAAAAAAAAAAREhQf/aAAgBAwEBPwFRpR//xAAYEQACAwAAAAAAAAAAAAAAAAAAAQIhQf/aAAgBAgEBPwFuWFn/xAAXEAEBAQEAAAAAAAAAAAAAAAAAIQEQ/9oACAEBAAY/Ak7NV//EABcQAQEBAQAAAAAAAAAAAAAAAAEAETH/2gAIAQEAAT8hz8YO4cZ3GJHWJVuFv//aAAwDAQACAAMAAAAQ3A//xAAXEQEBAQEAAAAAAAAAAAAAAAABACER/9oACAEDAQE/ECXEveX/xAAXEQADAQAAAAAAAAAAAAAAAAAAASER/9oACAECAQE/EMVCmn//xAAcEAACAgIDAAAAAAAAAAAAAAABEQAhMUFRYZH/2gAIAQEAAT8QXku2KqBWkCo8JiHUYO9GvIpPLxP/2Q=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"fire.jpg\"\n        title=\"Photo by https://unsplash.com/photos/HCCJgI4YwbQ\"\n        src=\"/static/fire-2047286e866179e69fc2e847d584d29f-80a2a.jpg\"\n        srcset=\"/static/fire-2047286e866179e69fc2e847d584d29f-49da2.jpg 275w,\n/static/fire-2047286e866179e69fc2e847d584d29f-8cc5e.jpg 550w,\n/static/fire-2047286e866179e69fc2e847d584d29f-80a2a.jpg 1100w,\n/static/fire-2047286e866179e69fc2e847d584d29f-d6076.jpg 1650w,\n/static/fire-2047286e866179e69fc2e847d584d29f-25733.jpg 2200w,\n/static/fire-2047286e866179e69fc2e847d584d29f-7c033.jpg 3000w\"\n        sizes=\"(max-width: 1100px) 100vw, 1100px\"\n      />\n    </span>\n  </span>\n  \n  <figcaption class=\"gatsby-resp-image-figcaption\">Photo by https://unsplash.com/photos/HCCJgI4YwbQ</figcaption>\n  </figure>\n      </p>\n<p>We use <a href=\"https://www.firebase.com\">Firebase</a> at <a href=\"https://yours.co\">Yours.co</a> for our entire backend. Our app depends upon cloud functions, datastore, push notifications and more.</p>\n<p>Firebase is well-suited to certain types of real-time applications. But, sometimes people ask me \"Should I use Firebase?\" Here are my open thoughts on Firebase's products and how they fit into a product's strategy.</p>\n<h2>A few caveats</h2>\n<ul>\n<li><a href=\"https://yours.co\">Our use case</a> is not your use case. Firebase can be well-suited to other applications.</li>\n<li>We don't use Firebase Cloud Firestore. It might be a lot better than their original Cloud Datastore product.</li>\n<li>Firebase is always getting better. Check <a href=\"https://www.firebase.com\">Firebase</a> to decide if it's a good fit for your needs.</li>\n</ul>\n<h2>Firebase: The Good Parts</h2>\n<p>Firebase is excellent for getting a product prototype or MVP off the ground. They take care of running your back end, and provide <a href=\"https://firebase.google.com/products/\">a suite of good services</a> for advanced features. They offer real-time syncing with your app, push notifications, and more. If you invest in the Firebase ecosystem, you can get up and running fast with very little overhead. You don't have to worry about managing servers and infrastructure. You also get Google's security and infrastructure teams supporting your product.</p>\n<p>Firebase also has a huge user community to bounce ideas off of and get guidance on best practices. Having an ecosystem around your technology decisions may help you move faster. Others may have already had the same problem and shared their solution to it with the world.</p>\n<p><strong>This might be good enough for many products, and these are great tools to use when you need them.</strong></p>\n<h2>Firebase: The problem</h2>\n<p>Unfortunately, many applications suffer from significant real-world constraints:</p>\n<ul>\n<li>Firebase's most advanced features introduce tight coupling between your app and database</li>\n<li>Firebase can make it hard to evolve your product.</li>\n<li>Firebase makes it hard to be backwards compatible</li>\n<li>Datastore makes updating complex data structures harder than alternatives like relational databases</li>\n<li>Firebase introduces significant lock-in with each component. This is a double-edged sword.</li>\n</ul>\n<p>These are the top points I would urge potential Firebase customers to consider.</p>\n<p>No technology is perfect. <em>Firebase might be the best solution to your specific situation</em>. Weigh your project's constraints against technology options. What can your team get done? What do you think you need to get done in the future?</p>\n<h2>Tight Coupling</h2>\n<p>This is the biggest issue, and it is essentially the root of the other problems listed above. Tight coupling means that different pieces of your application only functions when bundled together. A good example of this in the physical world would be a car that required one specific type of tire for every season. You couldn't change out for snow tires, touring tires, or some other specialized tire for a given trip you want to take. Without that specific tire, your car would be essentially worthless.</p>\n<p>When writing software, early decisions have huge impacts in the long-term path of the product. It's important to <strong>keep your options open</strong> and recognize that <strong>things will change</strong> over time. Startups suffer from this problem more than established products. <strong>The need for future agility is directly proportional to future product uncertainty</strong> Although the most important thing for products is to <a href=\"https://blog.ycombinator.com/tips-ship-early-and-often/\">ship early and ship often</a>, the second most important thing is enabling future growth. If the risk of future change is significantly high, it is important to more heavily consider how the choices of today will slow your execution tomorrow.</p>\n<p>Firebase introduces tight coupling because it encourages meshing your app's user interface with the backend database. This means that every breaking change to the user interface <em>or</em> data model forces some tough decisions. Do you update them both simultaneously? What if you maintain older versions? Tight coupling makes for poor backwards compatibility.</p>\n<p>If you are shipping a web application and you can release changes to both your backend and frontend simultaneously, then this is not as important. If you ship a mobile application or other versioned client, however, your backend may need to maintain some backwards compatiblity.</p>\n<p>Tight coupling also makes it difficult to change out components down the road if you want to. If you need to connect to a legacy backend or specialized data store, you may end up having two separate data paths in your application: one to access firebase content, and the other paths for separate backends. This may become more important over time as application needs evolve.</p>\n<p><strong>If you care about backwards compatibility, do not tightly couple your application with your database.</strong> Firebase makes this particular constraint very hard, if not impossible, to handle. The apps at <a href=\"https://yours.co\">Yours.co</a> check their version with the latest supported version and, if you are no longer supported, the app is frozen until the user updates the app on the App Store. For some use-cases this may be sub-optimal.</p>\n<h2>Updating complex data structures</h2>\n<p>Firebase datastore is essentially a document database with a single document in it.<a name=\"sup1\" href=\"#footnote1\"><sup>1</sup></a> Document databases were originally designed for handling unstructured data at massive scale for analytics. If you don't know the shape of your data in advance, document databases can be a terrific solution.</p>\n<p>Most applications, however, rely on known data with known fields. We know that users will sign up with an email address, have connections with other users, or that tweets are 280 characters long. This means that when using a document database (or other schemaless databases), your data's schema won't be handled by the database but will be baked into your application's code itself. This means that you are responsible for managing data integrity, not your database. This generally means that document databases are a poor fit for many applications.</p>\n<p>Additionally, Document databases can't handle relationships between different documents (or, in Firebase's case, pieces of the document) out of the box. At Yours.co, this means we have multiple duplicated collections with \"denormalized\" data in each of them. Although we have a <code>users</code> collection that describes information about each user generally, little bits of user data are sprinkled throughout our application so that our app doesn't have to stitch things together at runtime. <a href=\"https://en.wikipedia.org/wiki/Relational_database\">Relational databases</a> like Postgres or MariaDB let you combine different bits of data at query time and they return the results you ask for. Document databases, by contrast, generally return all of the different pieces you need separately, and your application must then join them together. This is more work for you, slower, and more error prone.</p>\n<p>Because of these facts, it is also harder to keep data in sync. If I have to keep a copy of some bit of data (like the user's email address) in a few different places in the database because of these constraints, if the user ever changes their email address I now have to remember to update that address anywhere else we store it in the system. This does not scale well, especially as a team evolves and develops a product. Data governance problems become more complex under a document-oriented model.</p>\n<h2>Real-time is overpromised</h2>\n<p>Firebase's killer feature is realtime data. It feels like magic to edit something on the client side and see it update in real time in a different part of the app. Firebase makes this possible, for free, out of the box. Unfortunately, if any of the above constraints apply to your situation, you may not get the real-time features you expect. Firebase's real-time features are only available if you tightly couple your frontend presentation to your backend data model in firebase. If you set up a REST or GraphQL API in front of Firebase, you have to re-implement your own realtime features in some other way. Not only that, but Firebase's realtime features are oriented around changes in your data, rather than application-level events. Instead of reacting to \"A user registered\" you would see \"An object was added to /users\".</p>\n<h2>Document security is hard to get right</h2>\n<p>Firebase's security model is built around writing a policy document that describes every piece of your data. This sounds like it gives you a single place for handling all of your security (which would be awesome).</p>\n<h2>Lock-in</h2>\n<p>Firebase offers a suite of tools ranging from database and user authentication to A/B testing and crash reporting. The entire suite is impressive, and we use several components at Yours.co to make our app work. Despite the above complaints, <strong>Firebase may be a good fit for some projects</strong>. That said, Firebase is a business built around getting you linked to a community of products. If you buy into authentication, you will probably want to use firestore or datastore. When you need to store uploaded user files, Firebase Storage is a convenient option. A/B testing, crash reporting, push notifications, and more are also just a few clicks away.</p>\n<p>This convenience is not a bad thing. This is precisely why Firebase can be a great tool for the right product. But, before committing to part of firebase, you may want to consider if you are okay with the rest of the products in the Firebase ecosystem? Although you could implement alternatives to them, that is more complicated than simply adopting what they offer directly. Weighing such trade offs is the essence of good software engineering and architecture.</p>\n<h2>When to use Firebase</h2>\n<p>I would recommend Firebase to new, greenfield projects that:</p>\n<ul>\n<li>Know what they need to achieve a good MVP out of the gate</li>\n<li>Don't want to fiddle with infrastructure concerns</li>\n<li>Are web-based only/Don't require backwards compatibility</li>\n<li>Have a small-ish team</li>\n</ul>\n<h2>What I recommend instead of Firebase</h2>\n<p>I personally recommend the technology a team is most comfortable with. For replicating the good parts of Firebase without using Firebase, I recommend the following blend:</p>\n<h3>Elixir + Phoenix</h3>\n<h3>Postgres</h3>\n<h3>GraphQL</h3>\n<h2>Footnotes</h2>\n<p><a name=\"footnote1\" href=\"#sup1\">1</a>: I have not used Firebase Firestore yet (it's still in beta), but it doesn't seem to include relational indices either.</p>","frontmatter":{"date":"October 15, 2018","title":"The problem with Firebase"},"fields":{"slug":"/blog/2018-10-15-firebase-problem/"}}},"pageContext":{}}